<aside>
ðŸ’¡ Reacp 


</aside>

## Card Matching Logic

```swift
// MARK: MODEL

import Foundation

struct MemoryGame<CardContent> where CardContent: Equatable {
    private(set) var cards: [Card]
    private var prevIndex: Int?
    var addCount: Int = 0
    
    mutating func chooseCard (_ card: Card) {
        /*  1. toggle card which is Selected(find selected card's index(id) */
        if let selectedIndex = cards.firstIndex(where: {$0.id == card.id}) {
        /* 2. Mathcing Logic */
            // ë‘ ë²ˆì§¸ ì„ íƒí–ˆì„ ë•Œ
            if prevIndex != nil {
                if cards[selectedIndex].content == cards[prevIndex!].content {
                    /* set ture value */
                    cards[selectedIndex].isMatched = true
                    cards[prevIndex!].isMatched = true
                }
                prevIndex = nil
            }
            // ì²« ë²ˆì§¸ ì„ íƒí–ˆì„ ë•Œ
            else {
                for index in cards.indices {
                    cards[index].isSelected = false
                }
            prevIndex = selectedIndex
            }
            cards[selectedIndex].isSelected.toggle()
        }
    }

    // Initialize card list
    init(pairOfIndexOfCard: Int, createContent: (Int) -> CardContent) {
        // initialize cards in init statement
        cards = [Card]()
        
        // Add two Pairof Card
        for index in 0 ..< pairOfIndexOfCard {
            let content: CardContent = createContent(index)
            cards.append(Card(content: content, id: index * 2))
            cards.append(Card(content: content, id: index * 2 + 1))
        }
    }
    
    struct Card: Identifiable {
        var isSelected: Bool = false
        var isMatched: Bool = false
        var content: CardContent
        var id: Int
    }
}
```

### 

### ChooseCard Business Logic

```swift
 mutating func chooseCard (_ card: Card) {
        /*  1. toggle card which is Selected(find selected card's index(id) */
        if let selectedIndex = cards.firstIndex(where: {$0.id == card.id}) {
        /* 2. Mathcing Logic */
            // ë‘ ë²ˆì§¸ ì„ íƒí–ˆì„ ë•Œ
            if prevIndex != nil {
                if cards[selectedIndex].content == cards[prevIndex!].content {
                    /* set ture value */
                    cards[selectedIndex].isMatched = true
                    cards[prevIndex!].isMatched = true
                }
                prevIndex = nil
            }
            // ì²« ë²ˆì§¸ ì„ íƒí–ˆì„ ë•Œ
            else {
                for index in cards.indices {
                    cards[index].isSelected = false
                }
            prevIndex = selectedIndex
            }
            cards[selectedIndex].isSelected.toggle()
        }
    }
```

### firstIndex(where: ...)

```swift
//MARK: Normal approach 
if let selectedIndex = cards[getIndexHandler] {
        /* 2. Mathcing Logic */

func getIndexHandler(_ card: Card) -> Int {
	for index in 0 <.. cards.count {
		if(index == card.id){
				return index
		}
	}
	return 0 // Not real retun value
}

  /* using fireIndex method */
if let selectedIndex = cards.firstIndex(where: {$0.id == card.id}) {
      
```

- ì¢€ ë” ì§ê´€ì ì´ê³  provableí•œ ì½”ë“œ

### array.indicies

```swift
//MARK: noraml for in
 for index in 0 ..< cards.count {
	 cards[index].isSelected = false
}

//MARK: using indicies method
for index in cards.indices {
                    cards[index].isSelected = false
                }             
              
```

- ìœ„ ì½”ë“œì²˜ëŸ¼ indiciesë©”ì†Œë“œë¥¼ ì´ìš©í•˜ë©´ ì¢€ ë” provableí•œ ì½”ë“œ ìž‘ì„± ê°€ëŠ¥

### optional Type

```swift
  private var prevIndex: Int?
```

ìœ„ ì½”ë“œì²˜ëŸ¼ ë³€ìˆ˜ì´ íŠ¹ì • ê°’ì´ í• ë‹¹ë˜ì§€ ì•Šì•˜ì„ ë•Œ nil ê°’ì„ ê°€ì§€ëŠ” íƒ€ìž…ìœ¼ë¡œ ì„ ì–¸ ê°€ëŠ¥

ê°•ì˜ì—ì„œëŠ” â€˜maybe it needs care typeâ€™ìœ¼ë¡œ í‘œí˜„. genericì€ â€˜donâ€™t care typeâ€™

## Emum

is is strcuture

but it has only dsicreate states...

```swift
emum FastFoodMenuItem {
	case hamburger
	case fires
	case drink
}
```

emum is a **value type (like struct)**. so it **is copied as it passed**

### Associated Data

ê° stateì—ëŠ” emuì˜ â€œassociated dataâ€ë¥¼ ê°€ì§€ê³  ìžˆë‹¤.

```swift
enum FryOrderSize {
	case large
	case small 
}
```

## Use firstIndex Method to Shorten the phrase

ì¹´ë“œë¼ëŠ” êµ¬ì¡°ë¥¼ ê°€ì§€ê³  ìžˆëŠ” ë°°ì—´ì¤‘ì— ìœ ì €ê°€ ì„ íƒí•œ ì¹´ë“œì˜ ì•„ì´ë””ë¥¼ ë°˜í™˜í•˜ëŠ” ë¡œì§

1) Forë¬¸ì„ ëŒë ¤ ì„ íƒëœ Id ê°’ì„ ë¦¬í„´í•˜ëŠ” Fuctionì„ ì‚¬ìš©í•¨

- ì´ë•Œ idë¥¼ ì°¾ì§€ ëª»í•˜ê±°ë‚˜ ì˜³ë°”ë¥¸ í˜•ì‹ì˜ ì¸ìžê°’ì„ í• ë‹¹ë°›ì§€ ëª»í–ˆì„ ê²½ìš° ì˜ˆì™¸ì²˜ë¦¬ë¥¼ í•  ìˆ˜ ì—†ìŒ
- ë‹¨ìˆœížˆ ì²«ë²ˆ ì§¸ ì¸ë±ìŠ¤ 0 ì„ ë°˜í™˜í•˜ëŠ” ì˜ˆì™¸ì²˜ë¦¬ë§Œ ì§„í–‰ ê°€ëŠ¥

```swift
struct MemoryGame <CardContent> {
    private(set) var cards: [Card]
    mutating func chooseCard(_ card: Card) {
        cards[getIndexHandler(card)].isSelected.toggle()
    }

		// ì„ íƒëœ ì¸ë±ìŠ¤ë¥´ ë°˜í™˜í•˜ëŠ” Func
    func getIndexHandler(_ card: Card) -> (Int) {
        for index in 0 ..< cards.count
            where card.id == index {
                return card.id
        }
        return 0
    }
   
	....
} 
```

2) Optionalì„ ì‚¬ìš©í•˜ì—¬ 0ì´ ì•„ë‹Œ nil ê°’ì„ ë¦¬í„´

```swift
struct MemoryGame <CardContent> {
	....

		// ì„ íƒëœ ì¸ë±ìŠ¤ë¥´ ë°˜í™˜í•˜ëŠ” Func
    func getIndexHandler(_ card: Card) -> Int? {
        for index in 0 ..< cards.count
            where card.id == index {
                return card.id
        }
        return nil
    }
   
	....
} 
```

- Function ë¦¬í„´ íƒ€ìž…ì— Optional íƒ€ìž…ì„ ì ìš©í•˜ì—¬ ì í•©í•œ ì¸ë±ìŠ¤ë¥¼ ì°¾ì§€ ëª»í• ê²½ìš° nil ê°’ì„ ë¦¬í„´í•˜ë„ë¡ í•¨.

3) â€˜firtIndexâ€™ ë©”ì†Œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ìœ„ 2)ë²ˆ ì˜ˆì œì²˜ëŸ¼ ì„ íƒëœ ì¸ë±ìŠ¤ ê°’ì„ ë¦¬í„´í•˜ëŠ” Functionì„ ë§Œë“¤ì§€ ì•Šê³  Arrayì•ˆì—ì„œ í•´ë‹¹ ë¡œì§ì„ êµ¬í˜„

```swift
struct MemoryGame <CardContent> {
	....

		mutating func chooseCard(_ card: Card) {
        if let selectedIndex = cards.firstIndex(where: {$0.id == card.id}) {
            cards[selectedIndex].isSelected.toggle()
        }
    }
   
	....
} 
```

##
